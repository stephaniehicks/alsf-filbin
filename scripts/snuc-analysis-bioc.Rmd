---
title: qc and analysis of single nuc-seq data (alsf-filbin)
author: Stephanie Hicks and Albert Kuo
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{bash}
# Commands to start an interactive session on the JHPCE cluster
qrsh -l mem_free=20G,h_vmem=20G
module load conda_R
cd /fastscratch/myscratch/akuo/alsf-filbin
R
```

```{r}
library(here)
```

# Creating SummarizedExperiment object

First, we create a table with information about where each file (quantified counts from salmon) is. 
This will be used to create a `SummarizedExperiment` object.

```{r}
# list tumor names
tumor_names <- list.files(here("sample_data"))[
                  !grepl("*.txt", list.files(here("sample_data")))]

unique_sf_paths <- NULL
for(tum in tumor_names){
  ids <- list.files(here("sample_data", tum))
  ids <- unique(stringr::str_sub(ids, end=-13))
  ids <- here("salmon_quants", paste0(ids, "_quant"), "quant.sf")
  unique_sf_paths <- c(unique_sf_paths, ids)
}

unique_sf_ids <- NULL
for(tum in tumor_names){
  ids <- list.files(here("sample_data", tum))
  ids <- unique(stringr::str_sub(ids, end=-13))
  unique_sf_ids <- c(unique_sf_ids, ids)
}

coldata <- data.frame(files = unique_sf_paths, names = unique_sf_ids)
```

We also need to use the linkedTxome object to use `tximeta` properly, i.e. `rowRanges(se)` won't be `NULL` and tximeta will be able to match the transcripts to the genes for us. **Note: still doesn't work**

```{r}
suppressPackageStartupMessages({
  library(tximeta)
  library(BiocFileCache)
})

# check if linkedTxome is already in the cache
bfcloc <- getTximetaBFC()
bfc <- BiocFileCache(bfcloc)
bfcinfo(bfc)

# if not, load linkedTxome json file
json_file <- here("salmon_files", "gencode.v32_salmon-index-v1.0.0.json")
loadLinkedTxome(json_file)
```

The only way I've figured out how to make this work for now is with `skipMeta = TRUE`.

```{r}
se_file_name = here("salmon_quants", "se.rds")

# coldata = coldata[1:2, ] # for testing
if(!file.exists(se_file_name)){
  # Create SummarizedExperiment object
  se <- tximeta(coldata, skipMeta = TRUE) # Takes a few minutes, file size = 597 MB
  # se <- tximeta(coldata, ignoreAfterBar = TRUE)
  saveRDS(se, se_file_name)
} else {
  se = readRDS(se_file_name) # Takes a couple of seconds
}

# Copy se file from fastscratch to local folder?
```

## Explore SummarizedExperiment object

```{r}
suppressPackageStartupMessages({
  library(SummarizedExperiment)
  library(DESeq2)
})

colData(se)
assayNames(se)
rowRanges(se)
```

```{r}
dat <- assay(se, "counts")
dat <- dat[!(rowSums(dat) == 0),]
dim(dat)
dat[grep("ENST00000355537.4", rownames(dat)),]
summary(colSums(dat))
hist(colSums(dat))
```

## Create SingleCellExperiment object

A SingleCellExperiment class is derived from the SummarizedExperiment class. The most important change is the addition of a new slot called `reducedDims`. Read more [here](https://osca.bioconductor.org/data-infrastructure.html#a-brief-recap-from-se-to-sce).

```{r}
# BiocManager::install('SingleCellExperiment')
library(SingleCellExperiment)
```

```{r}
sce = SingleCellExperiment(assays = list(counts = dat))

# you can access counts by assay(sce, "counts") or counts(sce)
# you can add a new entry to assays slot by assay(sce, "counts_new") = dat_new
```

## Quality Control

There are a couple of [QC metrics](https://osca.bioconductor.org/quality-control.html#choice-of-qc-metrics) to identify low-quality cells:

1. Using counts, i.e. cells with (a) a small library size (total sum of counts) `low_lib_size` or (b) few expressed endogeneous genes (nonzero counts for those genes) `low_n_features`
2. Using "spike-in transcripts", i.e. any enrichment of spike-in transcripts (higher proportion) 
3. Using the mitochondrial genome, i.e. any enrichment of reads in the mitochondrial genome is indicative of loss of cytoplasmic RNA

I will only do (1) for now.

```{r}
library(scater)

# Compute quality control metrics:
# sum is the total count for each cell
# detected contains the number of detected genes (actually transcripts for our data)
df = perCellQCMetrics(sce)
df
```

```{r}
# Find outliers with low library sizes (LibSize) and few detected features (n_features)
reasons = quickPerCellQC(df) # DataFrame of logical values
colSums(as.matrix(reasons))
```

```{r}
# Discard outliers
filtered = sce[, !reasons$discard] # 42 out of 576 cells were discarded

filtered_file_name = here("salmon_quants", "dat_filtered.rds")
saveRDS(filtered, filtered_file_name)
```

Diagnostic plots: https://osca.bioconductor.org/quality-control.html#quality-control-plots 

# Exploratory Plots of Counts

```{r}
library(here)
library(SingleCellExperiment)
library(ggplot2)
library(dplyr)
```

## Proportion of counts that are pre-mRNA

```{r}
filtered_file_name = here("salmon_quants", "dat_filtered.rds")
if(file.exists(filtered_file_name)){
  filtered = readRDS(filtered_file_name)
}

dat_filtered = counts(filtered)

# Split data into pre-mRNA and mRNA
dat_prem = dat_filtered[grepl(".premrna", rownames(dat_filtered)),]
dat_mrna = dat_filtered[!grepl(".premrna", rownames(dat)),]

# Proportion of counts that are pre_mRNA
premrna_prop = colSums(dat_prem)/colSums(dat_filtered)
summary(premrna_prop) # Min = 0.17, Median/Mean = 0.66, Max = 0.91
```

## Distribution of pre-mRNA

```{r}
# estimate lambdas and variances
lambdas = colMeans(dat_prem)
vars = apply(dat_prem, MARGIN = 2, var)

# variance = mean under Poisson distribution
# variance >> mean in data
tibble(lambdas, vars) %>%
  ggplot(aes(x = log(lambdas), y = log(vars))) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1) +
  labs(title = "pre-mRNA")
```

```{r}
# qqplot for first column
qprobs = seq(0.01, 0.99, by = 0.01)
plot(quantile(rpois(1000, lambda = lambdas[1]), qprobs),
     quantile(dat_prem[,1], probs = qprobs))
```

```{r}
# plot P(X=0) against the average expression level?
probs_0 = sapply(lambdas, function(lambda) dpois(0, lambda)) # P(X = 0)
vars = apply(dat_prem, MARGIN = 2, var)
```

## Distribution of mRNA

```{r}
# estimate lambdas and variances
lambdas_m = colMeans(dat_mrna)
vars_m = apply(dat_mrna, MARGIN = 2, var)

# variance = mean under Poisson distribution
# variance >> mean in data
tibble(lambdas_m, vars_m) %>%
  ggplot(aes(x = log(lambdas_m), y = log(vars_m))) + 
  geom_point() +
  geom_abline(intercept = 0, slope = 1) +
  labs(title = "mRNA")
```

```{r}
# qqplot for first column
qprobs = seq(0.01, 0.99, by = 0.01)
plot(quantile(rpois(1000, lambda = lambdas_m[1]), qprobs),
     quantile(dat_mrna[,1], probs = qprobs))
```


